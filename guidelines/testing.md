# Yotei Testing Guidelines

This document outlines the testing strategy and guidelines for the Yotei project.

## Overview

The Yotei project follows a pragmatic testing approach that focuses on business logic and user-facing functionality while minimizing infrastructure testing overhead.

## File Naming and Structure Conventions

### Test File Naming

- **Required Pattern**: `*.spec.ts` only
- **Prohibited**: `.test.ts` extension is forbidden
- **Examples**:
  - ✅ `calendar.spec.ts`
  - ✅ `create-event.spec.ts`
  - ❌ `calendar.test.ts`
  - ❌ `create-event.test.ts`

### Test File Colocation

- **Principle**: Test files must be colocated with their source files
- **Location**: Place test files in the same directory as the code they test
- **Structure**:
  ```
  modules/calendar/objects/write/
  ├── calendar.ts          # Source file
  ├── calendar.spec.ts     # Test file (colocated)
  ├── name.ts             # Source file
  └── name.spec.ts        # Test file (colocated)
  ```
- **Benefits**:
  - Easy to find related tests
  - Enforces test coverage awareness
  - Simplifies import paths

## Testing Strategy

### What to Test

#### 1. Domain Objects (Value Objects and Entities)

- **Priority**: High
- **Rationale**: Contains critical business rules and validation logic
- **Scope**: All validation functions, business rule enforcement, and domain logic

**Example layers to test:**

- `objects/write/` - Value object creation and validation
- `objects/read/` - Data transformation and business rules

#### 2. Workflows (Business Logic)

- **Priority**: High
- **Rationale**: Core business processes that directly impact user functionality
- **Scope**: End-to-end workflow logic, error handling, and business rule orchestration

**Example layers to test:**

- `workflows/` - Business logic coordination and validation
- API integration workflows

#### 3. API Endpoints

- **Priority**: Medium-High
- **Rationale**: User-facing functionality and integration points
- **Scope**: Request/response handling, validation, and error scenarios

### What NOT to Test

#### 1. Query Services

- **Rationale**: Primarily data access layer with minimal business logic
- **Alternative**: Integration tests and end-to-end tests cover these scenarios
- **Exception**: Complex query logic with business rules should be tested

#### 2. Repositories

- **Rationale**: Thin data access layer that primarily wraps ORM operations
- **Alternative**: Database integration tests provide better coverage
- **Exception**: Complex data transformation or business logic in repositories

#### 3. Database Schema and Migrations

- **Rationale**: Covered by database integration tests and production monitoring
- **Alternative**: Manual testing during development and staging deployment

## Testing Patterns

### Domain Object Testing

```typescript
// Generated by Copilot
import { describe, expect, test } from "vitest";
import { createCalendarName } from "./name";

describe("createCalendarName", () => {
  test("should create valid calendar name", () => {
    const result = createCalendarName("My Calendar");

    expect(result.isOk()).toBe(true);
    if (result.isOk()) {
      expect(result.value).toBe("My Calendar");
    }
  });

  test("should reject invalid input", () => {
    const result = createCalendarName("");

    expect(result.isErr()).toBe(true);
    if (result.isErr()) {
      expect(result.error).toBe("Invalid calendar name length");
    }
  });
});
```

### Workflow Testing

```typescript
// Generated by Copilot
import { describe, expect, test } from "vitest";
import {
  createCalendarWorkflow,
  toUnvalidatedCalendar,
} from "./create-calendar";

describe("createCalendarWorkflow", () => {
  test("should process valid calendar creation", () => {
    const input = toUnvalidatedCalendar({
      name: "Test Calendar",
      ownerId: "user-123",
    });

    const result = createCalendarWorkflow()(input);

    expect(result.isOk()).toBe(true);
    if (result.isOk()) {
      expect(result.value.kind).toBe("created");
      expect(result.value.name).toBe("Test Calendar");
    }
  });

  test("should handle validation errors", () => {
    const input = toUnvalidatedCalendar({
      name: "",
      ownerId: "user-123",
    });

    const result = createCalendarWorkflow()(input);

    expect(result.isErr()).toBe(true);
  });
});
```

## Test Commands

### Execution from Project Root

All test commands should be executed from the project root directory:

```bash
# API tests only
pnpm run test:api

# API code quality checks
pnpm run check:api

# All tests across workspace
pnpm test:all

# Specific app tests
pnpm --filter ./apps/api test
pnpm --filter ./apps/web test
```

### Development Workflow

1. **During Development**: Focus on domain objects and workflows
2. **Before Commit**: Run `pnpm run test:api && pnpm run check:api`
3. **Integration Testing**: Rely on end-to-end tests for data layer verification

## File Structure

```
modules/
├── calendar/
│   ├── objects/
│   │   └── write/
│   │       ├── name.ts
│   │       ├── name.spec.ts          ✅ Test these
│   │       ├── calendar.ts
│   │       └── calendar.spec.ts      ✅ Test these
│   ├── workflows/
│   │   ├── create-calendar.ts
│   │   └── create-calendar.spec.ts   ✅ Test these
│   ├── query-services/
│   │   └── get-calendars.ts         ❌ Skip testing
│   └── repositories/
│       └── save-calendar.ts         ❌ Skip testing
```

## Error Handling in Tests

### ValidationError Testing

```typescript
// Generated by Copilot
test("should handle validation errors correctly", () => {
  const result = createCalendar({ id: "", name: "", owner_id: "" });

  expect(result.isErr()).toBe(true);
  if (result.isErr()) {
    expect(result.error.message).toBe("Validation Error");
    expect(result.error.errors).toContain("Invalid calendar name length");
  }
});
```

### Never Throw Pattern

```typescript
// Generated by Copilot
test("should never throw exceptions", () => {
  expect(() => {
    createCalendarName("");
  }).not.toThrow();
});
```

## neverthrow Testing Guidelines

### Using Unsafe Methods in Tests

When testing domain objects that return `Result` types, use neverthrow's unsafe methods for cleaner test assertions:

#### \_unsafeUnwrap and \_unsafeUnwrapErr

- `_unsafeUnwrap()`: Use to extract the success value from `Ok` results
- `_unsafeUnwrapErr()`: Use to extract the error value from `Err` results
- **Only use these methods in test environments**

#### Example Usage

```typescript
// Instead of this:
expect(result.isOk()).toBe(true);
if (result.isOk()) {
  expect(result.value).toBe("expected-value");
}

// Use this for cleaner tests:
expect(result._unsafeUnwrap()).toBe("expected-value");
```

### Benefits

- **Cleaner tests**: Less conditional logic in test assertions
- **Better error messages**: Direct assertion failures show expected vs actual values
- **Simplified test code**: Reduces boilerplate conditional checks

## Vitest Best Practices

### Property Testing

Use `toHaveProperty` for object property validation:

```typescript
// Generated by Copilot
test("should have required properties", () => {
  const calendar = createCalendar(validInput)._unsafeUnwrap();

  expect(calendar).toHaveProperty("id");
  expect(calendar).toHaveProperty("name", "My Calendar");
  expect(calendar).toHaveProperty("ownerId");
});
```

### Array Length Testing

Use `toHaveLength` for array length validation:

```typescript
// Generated by Copilot
test("should return correct number of errors", () => {
  const result = createCalendar(invalidInput)._unsafeUnwrapErr();

  expect(result.errors).toHaveLength(2);
});
```

### Async Function Testing

Use `expect.assertions` at the beginning of async tests:

```typescript
// Generated by Copilot
test("should handle async operations", async () => {
  expect.assertions(2);

  const result = await someAsyncFunction();

  expect(result.isOk()).toBe(true);
  expect(result._unsafeUnwrap()).toBeDefined();
});
```

### Partial Object Matching

Use `toMatchObject` for partial object matching:

```typescript
// Generated by Copilot
test("should match partial object structure", () => {
  const calendar = createCalendar(validInput)._unsafeUnwrap();

  expect(calendar).toMatchObject({
    name: "My Calendar",
    ownerId: "user-123",
  });
  // Note: id is not checked as it's generated
});
```

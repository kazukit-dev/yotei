// Generated by Copilot
import { errAsync, okAsync } from "neverthrow";
import { describe, expect, it, vi } from "vitest";

import {
  AuthError,
  DBError,
  EntityNotFound,
  ValidationError,
} from "../../../shared/errors";
import {
  type Provider,
  signinWorkflow,
  toUnvalidatedSigninCommand,
} from "./signin";

// Mock providers and dependencies
const createMockProvider = (overrides: Partial<Provider> = {}): Provider => ({
  providerId: "auth0",
  exchangeCodeForToken: vi.fn().mockReturnValue(
    okAsync({
      accessToken: "access_token",
      refreshToken: "refresh_token",
      idToken: "id_token",
      expiresIn: 3600,
    }),
  ),
  verifyIdToken: vi.fn().mockReturnValue(okAsync(undefined)),
  getUserInfo: vi.fn().mockReturnValue(
    okAsync({
      id: "user123",
      name: "John Doe",
      email: "john@example.com",
      emailVerified: true,
    }),
  ),
  ...overrides,
});

const createMockFindOauth2User = (shouldFind = false) => {
  if (shouldFind) {
    return vi.fn().mockReturnValue(
      okAsync({
        user: {
          id: "existing-user-id",
          name: "John Doe",
          email: "john@example.com",
        },
        account: {
          account_id: "user123",
          user_id: "existing-user-id",
          provider_id: "auth0",
        },
      }),
    );
  }
  return vi
    .fn()
    .mockReturnValue(errAsync(new EntityNotFound("User not found")));
};

const createMockSaveOauthUser = () => {
  return vi.fn().mockReturnValue(okAsync(undefined));
};

describe("Signin Workflow", () => {
  describe("toUnvalidatedSigninCommand", () => {
    it("should create an unvalidated signin command", () => {
      const input = {
        code: "valid_code",
        code_verifier: "a".repeat(43),
      };

      const command = toUnvalidatedSigninCommand(input);

      expect(command).toEqual({
        kind: "unvalidated",
        input,
      });
    });
  });

  describe("signinWorkflow - successful flow", () => {
    it("should complete signin workflow for new user", async () => {
      const provider = createMockProvider();
      const findOauth2User = createMockFindOauth2User(false);
      const saveOauthUser = createMockSaveOauthUser();
      const clientId = "test-client-id";

      const command = toUnvalidatedSigninCommand({
        code: "valid_code",
        code_verifier: "a".repeat(43),
      });

      const workflow = signinWorkflow(
        clientId,
        provider,
        findOauth2User,
        saveOauthUser,
      );
      const result = await workflow(command);

      expect(result.isOk()).toBeTruthy();
      const sessionIssued = result._unsafeUnwrap();
      expect(sessionIssued.kind).toBe("session_issued");
      expect(sessionIssued.session).toMatchObject({
        id: expect.any(String),
        user_id: expect.any(String),
        expires_at: expect.any(Date),
        max_age: expect.any(Number),
      });

      // Verify all functions were called
      expect(provider.exchangeCodeForToken).toHaveBeenCalled();
      expect(provider.verifyIdToken).toHaveBeenCalled();
      expect(provider.getUserInfo).toHaveBeenCalled();
      expect(findOauth2User).toHaveBeenCalled();
      expect(saveOauthUser).toHaveBeenCalled();
    });

    it("should complete signin workflow for existing user", async () => {
      const provider = createMockProvider();
      const findOauth2User = createMockFindOauth2User(true);
      const saveOauthUser = createMockSaveOauthUser();
      const clientId = "test-client-id";

      const command = toUnvalidatedSigninCommand({
        code: "valid_code",
        code_verifier: "a".repeat(43),
      });

      const workflow = signinWorkflow(
        clientId,
        provider,
        findOauth2User,
        saveOauthUser,
      );
      const result = await workflow(command);

      expect(result.isOk()).toBeTruthy();
      const sessionIssued = result._unsafeUnwrap();
      expect(sessionIssued.kind).toBe("session_issued");
      expect(sessionIssued.session.user_id).toBe("existing-user-id");

      // Verify saveOauthUser was not called for existing user
      expect(saveOauthUser).not.toHaveBeenCalled();
    });
  });

  describe("signinWorkflow - validation errors", () => {
    it("should fail with validation error for invalid code", async () => {
      const provider = createMockProvider();
      const findOauth2User = createMockFindOauth2User();
      const saveOauthUser = createMockSaveOauthUser();

      const command = toUnvalidatedSigninCommand({
        code: "", // Invalid empty code
        code_verifier: "a".repeat(43),
      });

      const workflow = signinWorkflow(
        "client-id",
        provider,
        findOauth2User,
        saveOauthUser,
      );
      const result = await workflow(command);

      expect(result.isErr()).toBeTruthy();
      const error = result._unsafeUnwrapErr();
      expect(error).toBeInstanceOf(ValidationError);
    });

    it("should fail with validation error for invalid code verifier", async () => {
      const provider = createMockProvider();
      const findOauth2User = createMockFindOauth2User();
      const saveOauthUser = createMockSaveOauthUser();

      const command = toUnvalidatedSigninCommand({
        code: "valid_code",
        code_verifier: "short", // Too short
      });

      const workflow = signinWorkflow(
        "client-id",
        provider,
        findOauth2User,
        saveOauthUser,
      );
      const result = await workflow(command);

      expect(result.isErr()).toBeTruthy();
      const error = result._unsafeUnwrapErr();
      expect(error).toBeInstanceOf(ValidationError);
    });

    it("should fail with validation error for invalid user data from provider", async () => {
      const provider = createMockProvider({
        getUserInfo: vi.fn().mockReturnValue(
          okAsync({
            id: "user123",
            name: "", // Invalid empty name
            email: "john@example.com",
            emailVerified: true, // Keep email verified to avoid early failure
          }),
        ),
      });
      const findOauth2User = createMockFindOauth2User();
      const saveOauthUser = createMockSaveOauthUser();

      const command = toUnvalidatedSigninCommand({
        code: "valid_code",
        code_verifier: "a".repeat(43),
      });

      const workflow = signinWorkflow(
        "client-id",
        provider,
        findOauth2User,
        saveOauthUser,
      );
      const result = await workflow(command);

      expect(result.isErr()).toBeTruthy();
      const error = result._unsafeUnwrapErr();
      expect(error).toBeInstanceOf(ValidationError);
    });
  });

  describe("signinWorkflow - token exchange errors", () => {
    it("should fail when token exchange fails", async () => {
      const provider = createMockProvider({
        exchangeCodeForToken: vi
          .fn()
          .mockReturnValue(errAsync(new Error("Token exchange failed"))),
      });
      const findOauth2User = createMockFindOauth2User();
      const saveOauthUser = createMockSaveOauthUser();

      const command = toUnvalidatedSigninCommand({
        code: "valid_code",
        code_verifier: "a".repeat(43),
      });

      const workflow = signinWorkflow(
        "client-id",
        provider,
        findOauth2User,
        saveOauthUser,
      );
      const result = await workflow(command);

      expect(result.isErr()).toBeTruthy();
      const error = result._unsafeUnwrapErr();
      expect(error).toBeInstanceOf(AuthError);
      expect(error.message).toContain("Failed to get credentials");
    });
  });

  describe("signinWorkflow - token verification errors", () => {
    it("should fail when ID token verification fails", async () => {
      const provider = createMockProvider({
        verifyIdToken: vi
          .fn()
          .mockReturnValue(errAsync(new Error("Token verification failed"))),
      });
      const findOauth2User = createMockFindOauth2User();
      const saveOauthUser = createMockSaveOauthUser();

      const command = toUnvalidatedSigninCommand({
        code: "valid_code",
        code_verifier: "a".repeat(43),
      });

      const workflow = signinWorkflow(
        "client-id",
        provider,
        findOauth2User,
        saveOauthUser,
      );
      const result = await workflow(command);

      expect(result.isErr()).toBeTruthy();
      const error = result._unsafeUnwrapErr();
      expect(error).toBeInstanceOf(AuthError);
      expect(error.message).toContain("verifying the idToken");
    });

    it("should fail when email is not verified", async () => {
      const provider = createMockProvider({
        getUserInfo: vi.fn().mockReturnValue(
          okAsync({
            id: "user123",
            name: "John Doe",
            email: "john@example.com",
            emailVerified: false, // Email not verified
          }),
        ),
      });
      const findOauth2User = createMockFindOauth2User();
      const saveOauthUser = createMockSaveOauthUser();

      const command = toUnvalidatedSigninCommand({
        code: "valid_code",
        code_verifier: "a".repeat(43),
      });

      const workflow = signinWorkflow(
        "client-id",
        provider,
        findOauth2User,
        saveOauthUser,
      );
      const result = await workflow(command);

      expect(result.isErr()).toBeTruthy();
      const error = result._unsafeUnwrapErr();
      expect(error).toBeInstanceOf(AuthError);
      expect(error.message).toContain("Email is not verified");
    });

    it("should fail when getUserInfo fails", async () => {
      const provider = createMockProvider({
        getUserInfo: vi
          .fn()
          .mockReturnValue(errAsync(new Error("Failed to get user info"))),
      });
      const findOauth2User = createMockFindOauth2User();
      const saveOauthUser = createMockSaveOauthUser();

      const command = toUnvalidatedSigninCommand({
        code: "valid_code",
        code_verifier: "a".repeat(43),
      });

      const workflow = signinWorkflow(
        "client-id",
        provider,
        findOauth2User,
        saveOauthUser,
      );
      const result = await workflow(command);

      expect(result.isErr()).toBeTruthy();
      const error = result._unsafeUnwrapErr();
      expect(error).toBeInstanceOf(Error);
      expect(error.message).toContain("Failed to get user info");
    });
  });

  describe("signinWorkflow - database errors", () => {
    it("should fail when database find operation fails with DBError", async () => {
      const provider = createMockProvider(); // Uses default with emailVerified: true
      const findOauth2User = vi
        .fn()
        .mockReturnValue(errAsync(new DBError("Database connection failed")));
      const saveOauthUser = createMockSaveOauthUser();

      const command = toUnvalidatedSigninCommand({
        code: "valid_code",
        code_verifier: "a".repeat(43),
      });

      const workflow = signinWorkflow(
        "client-id",
        provider,
        findOauth2User,
        saveOauthUser,
      );
      const result = await workflow(command);

      expect(result.isErr()).toBeTruthy();
      const error = result._unsafeUnwrapErr();
      expect(error).toBeInstanceOf(DBError);
    });

    it("should fail when save operation fails", async () => {
      const provider = createMockProvider(); // Uses default with emailVerified: true
      const findOauth2User = createMockFindOauth2User(false);
      const saveOauthUser = vi
        .fn()
        .mockReturnValue(errAsync(new DBError("Failed to save user")));

      const command = toUnvalidatedSigninCommand({
        code: "valid_code",
        code_verifier: "a".repeat(43),
      });

      const workflow = signinWorkflow(
        "client-id",
        provider,
        findOauth2User,
        saveOauthUser,
      );
      const result = await workflow(command);

      expect(result.isErr()).toBeTruthy();
      const error = result._unsafeUnwrapErr();
      expect(error).toBeInstanceOf(DBError);
    });
  });

  describe("signinWorkflow - provider integration", () => {
    it("should pass correct parameters to provider methods", async () => {
      const provider = createMockProvider();
      const findOauth2User = createMockFindOauth2User(false);
      const saveOauthUser = createMockSaveOauthUser();
      const clientId = "test-client-id";

      const command = toUnvalidatedSigninCommand({
        code: "test_code",
        code_verifier: "a".repeat(50),
      });

      const workflow = signinWorkflow(
        clientId,
        provider,
        findOauth2User,
        saveOauthUser,
      );
      await workflow(command);

      // Verify exchangeCodeForToken was called with correct parameters
      expect(provider.exchangeCodeForToken).toHaveBeenCalledWith(
        "test_code",
        "a".repeat(50),
      );

      // Verify verifyIdToken was called with correct parameters
      expect(provider.verifyIdToken).toHaveBeenCalledWith("id_token", {
        audience: clientId,
        expirationTime: 3600,
      });

      // Verify getUserInfo was called with tokens
      expect(provider.getUserInfo).toHaveBeenCalledWith({
        idToken: "id_token",
        accessToken: "access_token",
        refreshToken: "refresh_token",
        expiresIn: 3600,
      });
    });
  });
});

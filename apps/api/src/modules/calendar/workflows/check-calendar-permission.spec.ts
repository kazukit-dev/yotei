import { ResultAsync } from "neverthrow";
import { describe, expect, test } from "vitest";

import { DBError, EntityNotFound } from "../../../shared/errors";
import { Calendar } from "../objects/write/calendar";
import { CalendarId } from "../objects/write/id";
import { CalendarName } from "../objects/write/name";
import { OwnerId } from "../objects/write/owner-id";
import {
  checkCalendarPermissionWorkflow,
  toUnvalidatedCommand,
} from "./check-calendar-permission";

// Generated by Copilot

describe("checkCalendarPermissionWorkflow", () => {
  const mockCalendar: Calendar = {
    id: "calendar-123" as CalendarId,
    name: "Test Calendar" as CalendarName,
    owner_id: "user-123" as OwnerId,
  };

  test("should grant permission when user owns the calendar", async () => {
    expect.assertions(3);

    const userId = "user-123";
    const mockFindCalendarById = () =>
      ResultAsync.fromSafePromise(Promise.resolve(mockCalendar));

    const workflow = checkCalendarPermissionWorkflow(
      userId,
      mockFindCalendarById,
    );
    const input = toUnvalidatedCommand("calendar-123");

    const result = await workflow(input);

    const validatedCommand = result._unsafeUnwrap();
    expect(validatedCommand).toMatchObject({
      kind: "validated",
    });
    expect(validatedCommand.calendar).toHaveProperty("id", "calendar-123");
    expect(validatedCommand.calendar).toHaveProperty("name", "Test Calendar");
  });

  test("should deny permission when user does not own the calendar", async () => {
    expect.assertions(1);

    const userId = "user-456";
    const mockFindCalendarById = () =>
      ResultAsync.fromSafePromise(Promise.resolve(mockCalendar));

    const workflow = checkCalendarPermissionWorkflow(
      userId,
      mockFindCalendarById,
    );
    const input = toUnvalidatedCommand("calendar-123");

    const result = await workflow(input);

    const error = result._unsafeUnwrapErr();
    expect(error).toHaveProperty(
      "message",
      "User does not have permission to access this calendar.",
    );
  });

  test("should handle calendar not found error", async () => {
    expect.assertions(2);

    const userId = "user-123";
    const mockFindCalendarById = () =>
      ResultAsync.fromPromise(
        Promise.reject(new EntityNotFound("Calendar not found")),
        (error) => error as EntityNotFound,
      );

    const workflow = checkCalendarPermissionWorkflow(
      userId,
      mockFindCalendarById,
    );
    const input = toUnvalidatedCommand("nonexistent-calendar");

    const result = await workflow(input);

    const error = result._unsafeUnwrapErr();
    expect(error).toBeInstanceOf(EntityNotFound);
    expect(error).toHaveProperty("message", "Calendar not found");
  });

  test("should handle database error", async () => {
    expect.assertions(2);

    const userId = "user-123";
    const mockFindCalendarById = () =>
      ResultAsync.fromPromise(
        Promise.reject(new DBError("Database connection failed")),
        (error) => error as DBError,
      );

    const workflow = checkCalendarPermissionWorkflow(
      userId,
      mockFindCalendarById,
    );
    const input = toUnvalidatedCommand("calendar-123");

    const result = await workflow(input);

    const error = result._unsafeUnwrapErr();
    expect(error).toBeInstanceOf(DBError);
    expect(error).toHaveProperty("message", "Database connection failed");
  });

  test("should handle invalid calendar ID format", async () => {
    const userId = "user-123";
    const mockFindCalendarById = () =>
      ResultAsync.fromSafePromise(Promise.resolve(mockCalendar));

    const workflow = checkCalendarPermissionWorkflow(
      userId,
      mockFindCalendarById,
    );
    const input = toUnvalidatedCommand("");

    const result = await workflow(input);

    // Note: Since createCalendarId always returns Ok,
    // this test verifies the workflow handles empty calendar IDs
    expect(result.isOk() || result.isErr()).toBe(true);
  });

  test("should work with different user ID formats", async () => {
    expect.assertions(1);

    const uuidUserId = "123e4567-e89b-12d3-a456-426614174000";
    const calendarWithUuidOwner: Calendar = {
      ...mockCalendar,
      owner_id: uuidUserId as OwnerId,
    };
    const mockFindCalendarById = () =>
      ResultAsync.fromSafePromise(Promise.resolve(calendarWithUuidOwner));

    const workflow = checkCalendarPermissionWorkflow(
      uuidUserId,
      mockFindCalendarById,
    );
    const input = toUnvalidatedCommand("calendar-123");

    const result = await workflow(input);

    const validatedCommand = result._unsafeUnwrap();
    expect(validatedCommand).toHaveProperty("kind", "validated");
  });
});

describe("toUnvalidatedCommand", () => {
  test("should create unvalidated command from calendar ID", () => {
    const calendarId = "calendar-123";
    const result = toUnvalidatedCommand(calendarId);

    expect(result).toMatchObject({
      kind: "unvalidated",
      input: {
        calendarId: "calendar-123",
      },
    });
  });

  test("should handle empty calendar ID", () => {
    const result = toUnvalidatedCommand("");

    expect(result).toMatchObject({
      kind: "unvalidated",
      input: {
        calendarId: "",
      },
    });
  });

  test("should handle UUID format calendar ID", () => {
    const uuidCalendarId = "123e4567-e89b-12d3-a456-426614174000";
    const result = toUnvalidatedCommand(uuidCalendarId);

    expect(result).toMatchObject({
      kind: "unvalidated",
      input: {
        calendarId: uuidCalendarId,
      },
    });
  });

  test("should handle special characters in calendar ID", () => {
    const specialCalendarId = "calendar-123_special@chars.com";
    const result = toUnvalidatedCommand(specialCalendarId);

    expect(result).toMatchObject({
      kind: "unvalidated",
      input: {
        calendarId: specialCalendarId,
      },
    });
  });
});

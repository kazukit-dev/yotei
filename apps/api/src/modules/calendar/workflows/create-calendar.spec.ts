import { describe, expect, test } from "vitest";

import {
  createCalendarWorkflow,
  toUnvalidatedCalendar,
  type UnvalidatedCalendar,
} from "./create-calendar";

// Generated by Copilot

describe("createCalendarWorkflow", () => {
  test("should create calendar successfully with valid input", () => {
    const input: UnvalidatedCalendar = {
      kind: "unvalidated",
      name: "My Calendar",
      ownerId: "user-123",
    };

    const workflow = createCalendarWorkflow();
    const result = workflow(input);

    const calendar = result._unsafeUnwrap();
    expect(calendar).toMatchObject({
      kind: "created",
      name: "My Calendar",
      ownerId: "user-123",
    });
    expect(calendar).toHaveProperty("id");
    expect(typeof calendar.id).toBe("string");
  });

  test("should reject invalid calendar name", () => {
    const input: UnvalidatedCalendar = {
      kind: "unvalidated",
      name: "",
      ownerId: "user-123",
    };

    const workflow = createCalendarWorkflow();
    const result = workflow(input);

    const error = result._unsafeUnwrapErr();
    expect(error.errors).toContain("Invalid calendar name length");
  });

  test("should reject invalid owner ID", () => {
    const input: UnvalidatedCalendar = {
      kind: "unvalidated",
      name: "My Calendar",
      ownerId: "",
    };

    const workflow = createCalendarWorkflow();
    const result = workflow(input);

    const error = result._unsafeUnwrapErr();
    expect(error.errors).toContain("UserId cannot be an empty string");
  });

  test("should reject both invalid name and owner ID", () => {
    const input: UnvalidatedCalendar = {
      kind: "unvalidated",
      name: "",
      ownerId: "",
    };

    const workflow = createCalendarWorkflow();
    const result = workflow(input);

    const error = result._unsafeUnwrapErr();
    expect(error.errors).toHaveLength(2);
    expect(error.errors).toContain("Invalid calendar name length");
    expect(error.errors).toContain("UserId cannot be an empty string");
  });

  test("should generate unique calendar IDs", () => {
    const input: UnvalidatedCalendar = {
      kind: "unvalidated",
      name: "Test Calendar",
      ownerId: "user-123",
    };

    const workflow = createCalendarWorkflow();
    const result1 = workflow(input);
    const result2 = workflow(input);

    const calendar1 = result1._unsafeUnwrap();
    const calendar2 = result2._unsafeUnwrap();
    expect(calendar1.id).not.toBe(calendar2.id);
  });

  test("should handle maximum length calendar name", () => {
    const maxLengthName = "a".repeat(256);
    const input: UnvalidatedCalendar = {
      kind: "unvalidated",
      name: maxLengthName,
      ownerId: "user-123",
    };

    const workflow = createCalendarWorkflow();
    const result = workflow(input);

    const calendar = result._unsafeUnwrap();
    expect(calendar).toHaveProperty("name", maxLengthName);
  });
});

describe("toUnvalidatedCalendar", () => {
  test("should create unvalidated calendar from input", () => {
    const input = {
      name: "Test Calendar",
      ownerId: "user-123",
    };

    const result = toUnvalidatedCalendar(input);

    expect(result).toMatchObject({
      kind: "unvalidated",
      name: "Test Calendar",
      ownerId: "user-123",
    });
  });

  test("should handle empty strings", () => {
    const input = {
      name: "",
      ownerId: "",
    };

    const result = toUnvalidatedCalendar(input);

    expect(result).toMatchObject({
      kind: "unvalidated",
      name: "",
      ownerId: "",
    });
  });

  test("should handle special characters", () => {
    const input = {
      name: "Calendar with émojis 🗓️",
      ownerId: "user-with-special@chars.com",
    };

    const result = toUnvalidatedCalendar(input);

    expect(result).toMatchObject({
      kind: "unvalidated",
      name: "Calendar with émojis 🗓️",
      ownerId: "user-with-special@chars.com",
    });
  });
});

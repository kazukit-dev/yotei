# Yotei Development Guidelines for Claude

This document contains all development guidelines for the Yotei project when working with Claude.

## üö® Critical: Workspace Verification Process

**MANDATORY**: After completing any development work, always run the following verification sequence:

```bash
pnpm run fix:all && pnpm run check:all && pnpm run test:all
```

This ensures code quality, consistency, and prevents regressions. See [Workspace Quality Assurance](#workspace-quality-assurance) for detailed information.

## Table of Contents

1. [General Coding Standards](#general-coding-standards)
2. [Development Guidelines](#development-guidelines)
3. [Testing Guidelines](#testing-guidelines)
4. [Architecture Patterns](#architecture-patterns)
5. [Command Execution & Package Management](#command-execution--package-management)
6. [Workspace Quality Assurance](#workspace-quality-assurance)

## General Coding Standards

### Core Principles
- Use TypeScript for all code
- Follow functional programming principles where applicable
- Implement proper validation with Zod schemas
- Follow React best practices for components
- Always add a comment: 'Generated by Claude'

### TypeScript Standards

- **Strict Type Safety**: Enable strict TypeScript settings
- **Prohibited Types**: Never use `any` type - use proper typing instead
- **Type Alternatives**: Use union types, generics, or `unknown` when type is uncertain
- **Type Definitions**: Define explicit interfaces and types for all data structures

#### Examples of Proper Typing

```typescript
// Generated by Claude
// ‚ùå Wrong: Using any
function processData(data: any): any {
  return data.someProperty;
}

// ‚úÖ Correct: Using proper types
interface UserData {
  id: string;
  name: string;
  email: string;
}

function processUserData(data: UserData): string {
  return data.name;
}

// ‚úÖ Correct: Using generics for unknown types
function processGenericData<T>(data: T): T {
  return data;
}

// ‚úÖ Correct: Using unknown for truly unknown data
function processUnknownData(data: unknown): string {
  if (typeof data === "object" && data !== null && "name" in data) {
    return String(data.name);
  }
  return "Unknown";
}
```

## Development Guidelines

### API Development

#### Error Handling
- Use neverthrow Result types for error handling in API
- Handle errors gracefully with neverthrow

#### Validation
- Validate all inputs with Zod
- Use proper HTTP status codes

#### Testing & Validation
- **Mandatory for API changes**: Run `pnpm run test:api` and `pnpm run check:api`
- Always run tests after making API changes: `pnpm test:all`

### Frontend Development

#### Components
- Use Remix conventions for routing and data loading
- Implement proper loading states
- Use React Aria Components for accessibility
- Follow component composition patterns

#### Styling
- Use Tailwind CSS for styling
- Follow consistent naming conventions

### Database Guidelines

#### ORM
- Use Drizzle ORM for database operations
- Write migrations for schema changes
- Follow naming conventions for tables and columns

#### Migrations
- Generate migrations with Drizzle Kit
- Test migrations locally before deployment

## Testing Guidelines

### Overview

The Yotei project follows a pragmatic testing approach that focuses on business logic and domain objects while minimizing infrastructure testing overhead. We prioritize testing components that directly implement business rules and validation logic.

### File Naming and Structure Conventions

#### Test File Naming
- **Required Pattern**: `*.spec.ts` only
- **Prohibited**: `.test.ts` extension is forbidden
- **Examples**:
  - ‚úÖ `calendar.spec.ts`
  - ‚úÖ `create-event.spec.ts`
  - ‚ùå `calendar.test.ts`
  - ‚ùå `create-event.test.ts`

#### Test File Colocation
- **Principle**: Test files must be colocated with their source files
- **Location**: Place test files in the same directory as the code they test
- **Structure**:
  ```
  modules/calendar/objects/write/
  ‚îú‚îÄ‚îÄ calendar.ts          # Source file
  ‚îú‚îÄ‚îÄ calendar.spec.ts     # Test file (colocated)
  ‚îú‚îÄ‚îÄ name.ts             # Source file
  ‚îî‚îÄ‚îÄ name.spec.ts        # Test file (colocated)
  ```

### Testing Strategy

#### Mandatory Test Execution
**CRITICAL**: After writing or modifying any tests, you MUST execute the following command to validate your changes:

```bash
pnpm run test:api
```

This command ensures that:
- All tests pass with the current implementation
- Test syntax and imports are correct
- No regressions have been introduced
- Test coverage requirements are met

**Failure to run this command after test modifications is a violation of testing guidelines.**

#### Test Priority Layers

| Layer                              | Test Priority | Rationale                                            |
| ---------------------------------- | ------------- | ---------------------------------------------------- |
| Domain Objects (`objects/`)        | **High**      | Contains core business rules and validation logic    |
| Workflows (`workflows/`)           | **High**      | Orchestrates business processes and application flow |
| API Layer (`api/`)                 | **Skip**      | Thin wrappers around workflows                       |
| Query Services (`query-services/`) | **Skip**      | Primarily data access with minimal logic             |
| Repositories (`repositories/`)     | **Skip**      | Thin data access layer                               |

#### What to Test
1. **Domain Objects (Value Objects and Entities)** - Priority: High
   - Contains critical business rules and validation logic
   - Scope: All validation functions, business rule enforcement, and domain logic

2. **Workflows (Business Logic)** - Priority: High
   - Core business processes that directly impact user functionality
   - Scope: End-to-end workflow logic, error handling, and business rule orchestration

#### What NOT to Test
1. **API Layer** - HTTP routes and handlers are primarily thin wrappers around workflows
2. **Query Services** - Primarily data access layer with minimal business logic
3. **Repositories** - Thin data access layer that primarily wraps ORM operations
4. **Database Schema and Migrations** - Covered by database integration tests

### Testing Patterns and Examples

#### Domain Object Testing
Test domain objects for valid input handling, invalid input rejection, and proper error messages.

```typescript
// Generated by Claude
import { describe, expect, test } from "vitest";
import { createCalendarName } from "./name";

describe("createCalendarName", () => {
  test("should create valid calendar name", () => {
    const result = createCalendarName("My Calendar");

    expect(result.isOk()).toBe(true);
    if (result.isOk()) {
      expect(result.value).toBe("My Calendar");
    }
  });

  test("should reject invalid input", () => {
    const result = createCalendarName("");

    expect(result.isErr()).toBe(true);
    if (result.isErr()) {
      expect(result.error).toBe("Invalid calendar name length");
    }
  });
});
```

#### Workflow Testing
Test workflows for proper business logic orchestration, validation, and error handling.

```typescript
// Generated by Claude
import { describe, expect, test } from "vitest";
import {
  createCalendarWorkflow,
  toUnvalidatedCalendar,
} from "./create-calendar";

describe("createCalendarWorkflow", () => {
  test("should process valid calendar creation", () => {
    const input = toUnvalidatedCalendar({
      name: "Test Calendar",
      ownerId: "user-123",
    });

    const result = createCalendarWorkflow()(input);

    expect(result.isOk()).toBe(true);
    if (result.isOk()) {
      expect(result.value.kind).toBe("created");
      expect(result.value.name).toBe("Test Calendar");
    }
  });

  test("should handle validation errors", () => {
    const input = toUnvalidatedCalendar({
      name: "",
      ownerId: "user-123",
    });

    const result = createCalendarWorkflow()(input);

    expect(result.isErr()).toBe(true);
  });
});
```

### Result Type Testing with neverthrow

When testing code that returns `Result` types, you can use two approaches:

#### Safe Approach (Conditional Assertions)
```typescript
// Generated by Claude
test("using safe conditional assertions", () => {
  const result = createCalendar({ name: "My Calendar", ownerId: "user-123" });

  expect(result.isOk()).toBe(true);
  if (result.isOk()) {
    expect(result.value.name).toBe("My Calendar");
  }
});
```

#### Concise Approach (Unsafe Methods)
Use neverthrow's unsafe methods for cleaner test assertions:

```typescript
// Generated by Claude
test("using unsafe methods for cleaner assertions", () => {
  const result = createCalendar({ name: "My Calendar", ownerId: "user-123" });

  const calendar = result._unsafeUnwrap();
  expect(calendar.name).toBe("My Calendar");
});
```

**Important notes about unsafe methods:**
- `_unsafeUnwrap()`: Extracts the success value from `Ok` results
- `_unsafeUnwrapErr()`: Extracts the error value from `Err` results
- **Only use these methods in test environments**

### Code Verification Process

#### Test-Driven Verification Methodology
When implementing or modifying code, follow this systematic verification process:

**Principle**: All code verification must be done through test code, not manual testing or console output.

```typescript
// Generated by Claude
// ‚ùå Wrong: Manual verification
console.log(createEmail("test@example.com")); // Don't do this

// ‚úÖ Correct: Test-driven verification
test("should verify email creation", () => {
  const result = createEmail("test@example.com");
  expect(result.isOk()).toBe(true);
});
```

#### Iterative Verification Cycle
Follow this cycle for all code changes:
1. **Write Verification Test** ‚Üí 2. **Run Test** ‚Üí 3. **Fix Code** ‚Üí 4. **Repeat**

```bash
# Example verification cycle
pnpm --filter ./apps/api test src/path/to/component.spec.ts  # Step 2: Run test
# Step 3: Fix code based on test results
# Step 4: Repeat until all tests pass
```

#### Cleanup After Verification
Once verification is complete:
1. **Delete**: Remove temporary verification/debug code
2. **Finalize**: Write clean, production-ready test code
3. **Validate**: Run full test suite with `pnpm run test:api`

### Development Testing Workflow
1. **Write Tests First**: Consider writing tests before implementation (TDD)
2. **Focus on Core Logic**: Prioritize testing domain objects and workflows
3. **Skip Infrastructure**: Don't test API endpoints, repositories, or query services
4. **Test After Changes**: Always run tests after modifying code
5. **Verify Before Commit**: Run complete test suite before committing code

### Testing Best Practices

#### Object Property Assertions
Use vitest's `toHaveProperty` method when checking object property values instead of direct property access. This provides better error messages and more descriptive test failures.

#### neverthrow Result Testing
Avoid conditional branching in tests. Use unsafe methods to extract values directly for cleaner test code.

**Success Pattern:**
```typescript
// Generated by Claude
test("should create event successfully", () => {
  const result = createEventWorkflow()(input);
  
  expect(result.isOk()).toBe(true);
  const event = result._unsafeUnwrap();
  expect(event).toHaveProperty("kind", "created");
  expect(event).toHaveProperty("title", "Meeting");
});
```

**Error Pattern:**
```typescript
// Generated by Claude
test("should reject invalid input", () => {
  const result = createEventWorkflow()(invalidInput);
  
  expect(result.isErr()).toBe(true);
  const error = result._unsafeUnwrapErr();
  expect(error).toBeInstanceOf(ValidationError);
  expect(error.errors).toContain("InvalidTitle");
});
```

**Note**: Unsafe methods should only be used in test environments.

### Quick Reference Summary
- **Focus**: Test domain objects and workflows primarily
- **File naming**: Use `*.spec.ts` pattern only (`.test.ts` is prohibited)
- **File location**: Colocate test files with source files
- **Commands**: `pnpm run test:api` and `pnpm run check:api` for API development

## Architecture Patterns

### Backend
- Domain-Driven Design: Features organized by domain modules
- Workflow Pattern: Business logic encapsulated in workflows
- Repository Pattern: Data access layer abstraction
- Clean Architecture: Clear separation of concerns

### Frontend
- Component-Based: Reusable UI components
- File-Based Routing: Remix routing conventions
- API Client Layer: Centralized API communication
- Query Management: TanStack Query for server state

## Command Execution & Package Management

### Working Directory
- **Always execute commands from the project root directory**
- Use workspace-aware commands to target specific apps/packages
- Avoid navigating to subdirectories to run commands

### Command Structure

```bash
# From project root - CORRECT
pnpm run test:api
pnpm run check:api
pnpm --filter ./apps/api test

# From subdirectory - AVOID
cd apps/api && pnpm test
```

### pnpm Workspace

- Use pnpm as the package manager for the monorepo
- Leverage workspace protocol (`workspace:*`) for internal dependencies
- Manage dependencies at the appropriate level (root vs app-specific)

### Dependency Management

- **Root dependencies**: Shared tools (ESLint, Prettier, TypeScript)
- **App-specific dependencies**: Framework-specific packages in respective apps
- **Package dependencies**: Utilities and shared configurations in packages/

### Common Commands

#### Basic Operations
- Install dependencies: `pnpm install`
- Add dependency to specific app: `pnpm --filter ./apps/api add <package>`
- Add dev dependency: `pnpm --filter ./apps/api add -D <package>`
- Remove dependency: `pnpm --filter ./apps/api remove <package>`
- Update dependencies: `pnpm update`
- Run scripts in specific app: `pnpm --filter ./apps/api <script>`

#### Root Workspace Operations
- Add root dependency (shared tools): `pnpm add -w <package>`
- Add root dev dependency: `pnpm add -D -w <package>`
- Remove root dependency: `pnpm remove -w <package>`
- Run script in all workspaces: `pnpm -r <script>`
- Run script in all workspaces (parallel): `pnpm -r --parallel <script>`
- Install dependencies for all workspaces: `pnpm install`
- Update all workspace dependencies: `pnpm update -r`

#### Testing Commands
All commands should be executed from the project root directory:

```bash
# During development
pnpm --filter ./apps/api test:watch    # Run tests in watch mode

# Before commit (mandatory)
pnpm run test:api                      # Run all API tests
pnpm run check:api                     # Run API code quality checks

# Complete verification
pnpm test:all                          # Run all tests across workspace

# Testing specific apps
pnpm --filter ./apps/api test          # Test API only
pnpm --filter ./apps/web test          # Test web app only
```

### Workspace Structure

- `apps/api/` - Backend API application
- `apps/web/` - Frontend web application
- `packages/eslint-config/` - Shared ESLint configurations

## Workspace Quality Assurance

### Standard Verification Process

After completing any development work, **ALWAYS** run the following commands in sequence to ensure code quality and project health:

```bash
# 1. Fix all code quality issues automatically
pnpm run fix:all

# 2. Verify code quality across workspace
pnpm run check:all

# 3. Run all tests to ensure functionality
pnpm run test:all
```

### Available Commands

#### Workspace-wide Commands
- `pnpm run fix:all` - Auto-fix formatting and linting issues across all packages
- `pnpm run check:all` - Run lint, format, and type checks across all packages
- `pnpm run test:all` - Execute all tests across all packages
- `pnpm run dev:all` - Start development servers for all apps

#### Package-specific Commands
- `pnpm run fix:api` - Auto-fix issues in API package only
- `pnpm run fix:web` - Auto-fix issues in Web package only
- `pnpm run check:api` - Quality checks for API package only
- `pnpm run check:web` - Quality checks for Web package only
- `pnpm run test:api` - Run API tests only

### Quality Check Components

#### 1. Fix Commands (`fix:all` / Package-specific)
- **Prettier**: Automatic code formatting
- **ESLint**: Auto-fixable linting issues
- **Purpose**: Ensures consistent code style
- **Examples**: `fix:all`, `fix:api`, `fix:web`

#### 2. Check Commands (`check:all` / Package-specific)
- **`lint:check`**: ESLint rule validation
- **`format:check`**: Prettier formatting validation
- **`typecheck`**: TypeScript compilation validation
- **Purpose**: Verifies code quality standards
- **Examples**: `check:all`, `check:api`, `check:web`

#### 3. Test Commands (`test:all` / Package-specific)
- **Unit Tests**: Domain objects and workflows
- **Integration Tests**: Component interactions
- **Purpose**: Ensures functionality and prevents regressions
- **Examples**: `test:all`, `test:api`

### Workflow Integration

This verification process should be integrated into your development workflow:

1. **During Development**: Use package-specific commands like `pnpm run fix:api` or `pnpm run fix:web` for quick fixes
2. **Before Commits**: Run the full verification process
3. **CI/CD Integration**: These commands are used in automated pipelines
4. **Code Reviews**: All changes must pass these checks

### Expected Results

All commands should complete successfully:

- ‚úÖ **fix:all**: No output indicates successful fixes
- ‚úÖ **check:all**: "All matched files use Prettier code style!" and no ESLint/TypeScript errors
- ‚úÖ **test:all**: All tests pass (e.g., "132/132 tests passed")

### Troubleshooting

If any command fails:

1. **Fix Issues**: Address the specific errors reported
2. **Re-run**: Execute the failed command again
3. **Iterate**: Repeat until all checks pass
4. **Seek Help**: If persistent issues, consult team or documentation